<import name="title" src="../title"></import>
<import name="finish" src="../doneWork"></import>
 
<template>
  <div class="card-wrapper">
    <stack class="outter-wrapper">
      <title class="title"></title>
      <div class="started" if="{{showDistribute('READY')}}">
        <div class="button-wrap">
          <text class="button-started" onclick="handleClickToStarted"
            >点击开始吧</text
          >
        </div>
      </div>
      <!--显示计时容器区域-->
      <div class="clock-wrapper" if="{{showDistribute('TIMEING')}}">
        <stack class="stack">
          <div class="loop"></div>
          <canvas id="canvas-id"></canvas>
          <text class="time">{{ currentTime }}</text>
        </stack>
      </div>
      <!-- <finish class="finish-wrapper" if="{{showDistribute('FINISH')}}"> </finish> -->
    </stack>

    <!--显示完成区域-->
  </div>
</template>

<script>
import utils from '../helper/utils.js'
const CARD_STATUS = {
  READY: 1,
  UNREADY: 0,
  TIMEING: 2,
  FINISH: 3
}
export default {
  private: {
    windowWidth: 100,
    windowHeight: 100,
    ratio: 1,
    ctx: {},
    percentage: 0,
    timeout: {},
    circleX: '',
    circleY: '',
    circleR: '',
    circleAngle: Math.PI * 180,
    time: 180,
    percentageBy100: 0,
    showStatus: 3,
  },
  computed: {
    currentTime() {
      let min = Math.floor(this.time / 60)
      let sec = this.time % 60
      min += ''
      sec += ''
      min = (min.length === 1) ? '0' + min : min
      sec = (sec.length === 1) ? '0' + sec : sec
      return min + ':' + sec
    },

  },
  async onShow() {
  },
  //点击开始计时
  async handleClickToStarted() {
    this.showStatus = CARD_STATUS.TIMEING
    setTimeout(async () => {
      await this.getWidth(this.$element('canvas-id'))
      const canvas = this.$element('canvas-id')
      this.ctx = await this.adaptCanvas(canvas.getContext('2d'))
      await this.draw(this.ctx)
      this.startTime(this.ctx)
    }, 500)
  },
  getWidth(dom) {
    const self = this
    return new Promise((resolve, reject) => {
      dom.getBoundingClientRect({
        success: function (data) {
          console.log(JSON.stringify(data))
          const { top, bottom, left, right, width, height } = data
          self.windowWidth = width
          self.windowHeight = height
          resolve()
        },
        fail: (errorData, errorCode) => {
          reject()
        },
        complete: function () {
          console.log('complete')
        }

      })
    })
  },
  async adaptCanvas(context) {
    const device = await utils.getDevice()
    context.ratio = device.screenDensity
    this.ratio = device.screenDensity
    console.log(this.ratio)
    return context
  },
  async draw(ctx) {
    try {
      // ctx.context.shadowOffsetX = 1

      ctx.beginPath()
      this.circleX = this.windowWidth / 2 / this.ratio
      this.circleY = this.windowHeight / 2 / this.ratio
      ctx.arc(this.windowWidth / 2 / this.ratio, this.windowHeight / 2 / this.ratio, 50, 0, 2 * Math.PI, false)
      ctx.lineWidth = 11 * this.ratio
      ctx.strokeStyle = '#5c6b1b'
      console.log(ctx.context)
      ctx.stroke()
      ctx.save()

    }
    catch (e) {
      console.log(e)
    }
  },
  startTime(ctx) {
    try {
      const self = this
      this.timeout = setInterval(() => {
        if (self.percentage <= 100) {
          const startAngle = 3 / 2 * Math.PI
          const percentage = self.percentage
          self.percentage = percentage + 0.55555
          this.time = this.time = 0 ? 0 : this.time - 1
          if (this.percentage > this.percentageBy100) {
            const remainder = Math.floor(this.percentage / 1)
            if (remainder > this.percentageBy100) {
              this.percentageBy100 += 1
              const diffAngle = percentage / 100 * Math.PI * 2
              this.circleAngle = diffAngle
              ctx.beginPath()
              ctx.lineWidth = 8 * this.ratio
              ctx.arc(this.windowWidth / 2 / this.ratio, this.windowHeight / 2 / this.ratio, 50, startAngle, diffAngle + startAngle, false)
              ctx.lineCap = "round"
              ctx.strokeStyle = '#cce451'
              ctx.stroke()
              // ctx.beginPath()
              // console.log(ctx)
            }
            else { }
          }

        }
        else {
          clearInterval(this.timeout)
        }
      }, 1000)
    }
    catch (e) {
      console.log(e)
    }
  },
  showDistribute(status) {
    return CARD_STATUS[status] === this.showStatus
  }
}
</script>

<style>
.card-wrapper {
  width: 100%;
  height: 100%;
  justify-content: center;
  align-items: center;
  background-color: #cce55e;
  padding: 0;
}
#canvas-id {
  width: 152dp;
  height: 152dp;
}
.loop {
  width: 110dp;
  height: 110dp;
  border-radius: 50%;
  background-color: #5c6b1b;
}
.stack {
  display: flex;
  justify-content: center;
  align-items: center;
}
.time {
  font-size: 22dp;
  font-weight: bold;
  color: white;
}
.started {
  width: 100%;
  height: 100%;
  flex: 1;
  justify-content: center;
  align-items: center;
}
.button-wrap {
  width: 120dp;
  height: 120dp;
  border-radius: 50%;
  border: 10dp 1px solid white;
  background-color: #6adfb9;
  display: flex;
  justify-content: center;
  align-items: center;
}
.button-started {
  font-size: 20dp;
  color: white;
  height: 20dp;
  font-weight: bold;
}
.clock-wrapper {
  width: 100%;
  height: 100%;
  flex: 1;
  justify-content: center;
  align-items: center;
}
.title{
  height: 40dp;
  width: 100%;
}
.outter-wrapper{
  width: 100%;
  height: 100%;
  flex: 1;
  flex-direction: row;
}
</style>
